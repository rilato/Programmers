// 2차원 배열을 1차원처럼 생각하여 풀었다.
// 0 1 2 3 4 5 6 7 8 9 10
// 11 12 13 14 15 16 17 18 19 20 ...

// dirs[i] == 'L'인 조건에서, now가 0인 경우, 조건을 잘 따져주어야 한다. (seg fault가 발생하지 않도록)

#include <string>
#include <vector>
#include <queue>

using namespace std;

int solution(string dirs) {
    int answer = 0;
    
    // 0 1 2 3 4 5 6 7 8 9 10
    // 11 12 13 14 15 16 17 18 19 20 ...
    
    // 60이 (0, 0)
    vector <int> v(121);
    vector <vector <int>> visitedRoad(121);
    queue <int> q;
    
    q.push(60);
    
    for (int i = 0; i < dirs.size(); i++) {
        int now = q.front();
        int next;
        
        q.pop();
        
        if (dirs[i] == 'U') {
            next = now - 11;
            
            if (next < 0) {
                q.push(now);
                continue;
            }
        }
        if (dirs[i] == 'D') {
            next = now + 11;
            
            if (next > 120) {
                q.push(now);
                continue;
            }
        }
        if (dirs[i] == 'L') {
            next = now - 1;
            
            // L        / next L
            // now : 0  / next : 0
            // 11       / next : 10
            // 22       / next : 21
            // 33       / next : 32
            // => 11로 나누었을 때 나머지가 10인 애들
            if (next % 11 == 10 || now == 0) {
                q.push(now);
                continue;
            }
        }
        if (dirs[i] == 'R') {
            next = now + 1;
            
            // R        / next R
            // now : 10 / next : 11
            // 21       / next : 22
            // 32       / next : 33
            // 120      / next : 120
            // => 11로 나누었을 때 나머지가 0인 애들
            if (next % 11 == 0) {
                q.push(now);
                continue;
            }
        }
        
        for (int j = 0; j < visitedRoad[now].size(); j++) {
            // 이미 방문한 길
            if (visitedRoad[now][j] == next) {
                answer--;
                break;
            }
        }
        
        answer++;
        visitedRoad[now].push_back(next);
        visitedRoad[next].push_back(now);
        q.push(next);
    }
    
    return answer;
}
